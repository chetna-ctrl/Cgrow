-- IoT Hybrid System Database Setup
-- This enables both manual and sensor-based data entry
-- Backward compatible - existing manual users unaffected

-- ============================================
-- TABLE 1: sensor_readings
-- Stores high-frequency sensor data from IoT devices
-- ============================================

CREATE TABLE IF NOT EXISTS sensor_readings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- Device Info
  device_id VARCHAR(50) NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Target Assignment (which crop is being monitored)
  batch_id BIGINT REFERENCES batches(id) ON DELETE SET NULL,
  target_id BIGINT REFERENCES systems(id) ON DELETE SET NULL,
  
  -- Sensor Data (all optional - depends on what sensors are connected)
  temperature NUMERIC(5,2),           -- Air temperature (°C)
  humidity NUMERIC(5,2),              -- Relative humidity (%)
  ph NUMERIC(4,2),                    -- pH level (0-14)
  ec NUMERIC(6,2),                    -- Electrical Conductivity (mS/cm)
  water_temp NUMERIC(5,2),            -- Water temperature (°C)
  water_level NUMERIC(6,2),           -- Water level (cm or %)
  soil_moisture_1 NUMERIC(5,2),       -- Soil moisture sensor 1 (%)
  soil_moisture_2 NUMERIC(5,2),       -- Soil moisture sensor 2 (%)
  light_intensity NUMERIC(8,2),       -- Light (Lux or PPFD)
  co2_ppm NUMERIC(6,0),               -- CO2 concentration (ppm)
  
  -- Metadata
  reading_time TIMESTAMPTZ DEFAULT NOW(),  -- Renamed from 'timestamp' (reserved keyword)
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for fast queries
CREATE INDEX IF NOT EXISTS idx_sensor_readings_device ON sensor_readings(device_id, reading_time DESC);
CREATE INDEX IF NOT EXISTS idx_sensor_readings_user ON sensor_readings(user_id, reading_time DESC);
CREATE INDEX IF NOT EXISTS idx_sensor_readings_batch ON sensor_readings(batch_id, reading_time DESC);
CREATE INDEX IF NOT EXISTS idx_sensor_readings_target ON sensor_readings(target_id, reading_time DESC);
CREATE INDEX IF NOT EXISTS idx_sensor_readings_time ON sensor_readings(reading_time DESC);

-- ============================================
-- TABLE 2: iot_devices
-- Registry of all IoT devices owned by users
-- ============================================

CREATE TABLE IF NOT EXISTS iot_devices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  
  -- Device Identification
  device_id VARCHAR(50) UNIQUE NOT NULL,  -- Unique hardware ID (e.g., "CGROW-001")
  device_name VARCHAR(100),               -- User-friendly name (e.g., "Radish Tray Sensor")
  device_type VARCHAR(50) DEFAULT 'cGrow-Kit-v1',
  
  -- Owner
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Assignment (which crop is this device monitoring)
  batch_id BIGINT REFERENCES batches(id) ON DELETE SET NULL,
  target_id BIGINT REFERENCES systems(id) ON DELETE SET NULL,
  
  -- Status
  status VARCHAR(20) DEFAULT 'offline',   -- online/offline/error
  last_seen TIMESTAMPTZ,
  battery_level NUMERIC(5,2),             -- Battery percentage (0-100)
  firmware_version VARCHAR(20),
  
  -- Configuration
  wifi_ssid VARCHAR(100),
  calibration_data JSONB,                 -- pH/EC calibration values
  sensor_config JSONB,                    -- Which sensors are enabled
  
  -- Metadata
  registered_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_iot_devices_user ON iot_devices(user_id);
CREATE INDEX IF NOT EXISTS idx_iot_devices_status ON iot_devices(status);
CREATE INDEX IF NOT EXISTS idx_iot_devices_batch ON iot_devices(batch_id);
CREATE INDEX IF NOT EXISTS idx_iot_devices_target ON iot_devices(target_id);

-- ============================================
-- ENABLE REALTIME (for live sensor updates)
-- ============================================

-- Enable Realtime for sensor_readings table
ALTER PUBLICATION supabase_realtime ADD TABLE sensor_readings;

-- Enable Realtime for iot_devices table (for status updates)
ALTER PUBLICATION supabase_realtime ADD TABLE iot_devices;

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- Users can only see their own devices and sensor data
-- ============================================

-- Enable RLS
ALTER TABLE sensor_readings ENABLE ROW LEVEL SECURITY;
ALTER TABLE iot_devices ENABLE ROW LEVEL SECURITY;

-- Policies for sensor_readings
CREATE POLICY "Users can view their own sensor readings"
  ON sensor_readings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own sensor readings"
  ON sensor_readings FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Devices can insert sensor readings"
  ON sensor_readings FOR INSERT
  WITH CHECK (true); -- Allow devices to insert (authenticated via API key)

-- Policies for iot_devices
CREATE POLICY "Users can view their own devices"
  ON iot_devices FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own devices"
  ON iot_devices FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own devices"
  ON iot_devices FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own devices"
  ON iot_devices FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- HELPER FUNCTIONS
-- ============================================

-- Function to get latest sensor reading for a device
CREATE OR REPLACE FUNCTION get_latest_sensor_reading(p_device_id VARCHAR)
RETURNS TABLE (
  temperature NUMERIC,
  humidity NUMERIC,
  ph NUMERIC,
  ec NUMERIC,
  water_temp NUMERIC,
  reading_time TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sr.temperature,
    sr.humidity,
    sr.ph,
    sr.ec,
    sr.water_temp,
    sr.reading_time
  FROM sensor_readings sr
  WHERE sr.device_id = p_device_id
  ORDER BY sr.reading_time DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to update device last_seen timestamp
CREATE OR REPLACE FUNCTION update_device_last_seen()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE iot_devices
  SET 
    last_seen = NEW.reading_time,
    status = 'online',
    updated_at = NOW()
  WHERE device_id = NEW.device_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update device status when sensor data arrives
CREATE TRIGGER trigger_update_device_status
  AFTER INSERT ON sensor_readings
  FOR EACH ROW
  EXECUTE FUNCTION update_device_last_seen();

-- ============================================
-- SAMPLE DATA (for testing)
-- ============================================

-- Uncomment below to insert sample device for testing
/*
INSERT INTO iot_devices (
  device_id,
  device_name,
  device_type,
  user_id,
  status,
  firmware_version
) VALUES (
  'CGROW-TEST-001',
  'Test Sensor Kit',
  'cGrow-Kit-v1',
  (SELECT id FROM auth.users LIMIT 1), -- Replace with actual user_id
  'offline',
  'v1.0.0'
);
*/

-- ============================================
-- VERIFICATION QUERIES
-- ============================================

-- Check if tables were created successfully
SELECT 
  table_name,
  (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = t.table_name) as column_count
FROM information_schema.tables t
WHERE table_schema = 'public' 
  AND table_name IN ('sensor_readings', 'iot_devices')
ORDER BY table_name;

-- Check indexes
SELECT 
  tablename,
  indexname
FROM pg_indexes
WHERE schemaname = 'public'
  AND tablename IN ('sensor_readings', 'iot_devices')
ORDER BY tablename, indexname;
